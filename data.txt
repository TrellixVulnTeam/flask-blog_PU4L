-- MySQL dump 10.13  Distrib 5.7.21, for Win64 (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.7.21

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `album`
--

DROP TABLE IF EXISTS `album`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `album` (
  `id` tinyint(4) NOT NULL AUTO_INCREMENT,
  `title` varchar(64) DEFAULT NULL,
  `about` text,
  `timestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `album`
--

LOCK TABLES `album` WRITE;
/*!40000 ALTER TABLE `album` DISABLE KEYS */;
INSERT INTO `album` VALUES (16,'FordCar','赛车是男人的浪漫','2018-04-13 03:36:58'),(17,'Views','趁着青春年少，抓紧时间拍照','2018-04-13 03:37:40');
/*!40000 ALTER TABLE `album` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `book`
--

DROP TABLE IF EXISTS `book`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `book` (
  `id` tinyint(4) NOT NULL AUTO_INCREMENT,
  `title` varchar(64) NOT NULL,
  `body` longtext,
  `body_html` longtext,
  `timestamp` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `book`
--

LOCK TABLES `book` WRITE;
/*!40000 ALTER TABLE `book` DISABLE KEYS */;
INSERT INTO `book` VALUES (1,'书单整理','这几天突发奇想，打算把高中毕业以来读过的书整理一遍，做个书单，方便日后查看，也可以给后来者一些参考。因为平时读的书比较杂，所以这份书单里的书也不仅限于一个方向，都是我读过以后觉得还不错的，推荐给大家。  \n# 悬疑推理\n老实说这方面的书我看的不多，印象比较深的就只有东野圭吾写的几本了(～￣▽￣)～ (～￣▽￣)～ \n## 白夜行\n![](http://p1csf090h.bkt.clouddn.com/%E7%99%BD%E5%A4%9C%E8%A1%8C.jpg)  \n这个不多说，东野的代表作，基本上东野迷人手一本吧。如果你没看过推理小说，或者以前没有接触过东野圭吾，那么从入手这本书不会有错的~\n## 解忧杂货店\n![](http://p1csf090h.bkt.clouddn.com/%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E5%BA%97.jpg)  \n东野另一代表作，在日本和国内分别都有翻拍的电影。建议看完书以后有兴趣的话可以看一下日本翻拍的那部电影，至于国产的嘛....如果你是王俊凯的粉丝可以看看￣ω￣=  \n说回这本书，书里人物的命运相互交织，冥冥中似乎有一张巨大的网把他们联系在一起：为了躲避抓捕慌乱中躲进杂货店的小贼，被情所困的运动员，为未来彷徨的歌手...我常常会想，自己是否也会像书里说的那样，无意之间改变了他人的命运的走向。毕竟人生在世，没有谁是一座孤岛，再特立独行的人也必定会受到别人的影响。\n## 嫌疑人X的献身\n![](http://p1csf090h.bkt.clouddn.com/book/%E5%AB%8C%E7%96%91%E4%BA%BA.jpg)  \n如果说刚才两本书着力点在人心，这本书则更注重推理。数学天才为了包庇自己爱的人与警方斗智斗勇的故事。滴水不漏的思维，细致入微的推理，整个故事看下来还是很爽的。毕竟推理小说有点类似于复联这种爽片，能做到人文剧情两不误当然最好，如果不能，单是剧情精彩也就足够了。\n# 编程\n嘿嘿，毕竟这小一年都在学习这方面的知识，所以这方面的书看得会多些￣ω￣=  \n学习过程中踩过不少坑，有些书写的水平实在一般，有时自己又太着急了买了些自己还没办法理解的书，有时看完一本书后不知道下一步该怎么办...所以我会按自己的学习路线来给下面的书排版。不过要说明的是，我目前的学习方向是爬虫+后端开发，推荐的书也是以这两方面的居多。当然，现在网上有很多的教学视频，但是视频内容大多不全面，且对我来说视频学习效率不如看书，如果书上有内容看不懂，可以找些相关的视频来看看，有时候会有奇效。\n## C primer plus\n![](http://p1csf090h.bkt.clouddn.com/book/C%20primer%20plus.jpg)  \nC入门的经典书籍，C是大部分现代编程语言之母，而且学习C的过程中你还会了解到很多关于计算机底层的知识，所以就算你不准备把C作为主力编程语言，起码也要了解C。这本书说实话挺厚的，不过千万不要被它的厚度吓到了，作为入门我们只需要学习它前半部分的内容，后面的算法知识可以等到以后再补。\n\n## Python编程-从入门到实战\n![](http://p1csf090h.bkt.clouddn.com/book/python%E5%85%A5%E9%97%A8.jpg)  \n很不错的一本Python入门书，基于Python3（要知道python2在2020年就要停止维护了，所以现在入门的话python3是最佳选择）。基本把python基础语法都讲到了，每一个知识点都附有代码实例，章节末尾还有对应的练习。最可贵的是教学节奏把握的不错，学习的时候不会有很无聊的感觉。书末还有3个不错的实战项目，跟着这本书学下来python也就入门了。读完这本书之后如果想进一步加深对python的了解可以看一下廖雪峰老师的Python教程[廖雪峰的python教程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000)。这个教程也是python入门的好资料，不过难度跨越有点大，等有一点python基础之后看效果更好些。\n## 图解HTTP\n![](http://p1csf090h.bkt.clouddn.com/book/%E5%9B%BE%E8%A7%A3http.jpg)  \n初学HTTP的好书。学习http主要是因为后面的爬虫和web开发都要用到很多http方面的知识。这是一本日本人写的书，风格幽默风趣，最最棒的是书中有大量的插画帮助理解。类似的还有一本书叫《图解TCP/IP》,这里就不单独介绍了。\n## Python爬虫开发与项目实战\n![](http://p1csf090h.bkt.clouddn.com/book/python%E7%88%AC%E8%99%AB.jpg)  \n既然已经入门了，当然要称热打铁，找些实际项目来练练手啦，爬虫就是一个很好的练手方向，看着数据一条条地被你从网上抓取下来，会很有成就感的~作为爬虫教程这本书写的很不错，从最基础的爬取静态网页开始，到爬取js渲染的动态网站，再到模拟登陆，处理验证码，反爬...还涉及分布式爬虫的内容。后半部分还对目前最火的python爬虫框架——Scrapy进行了讲解。读完这本书一般的网站都难不住你了。\n## Python核心编程(第三版)\n![](http://p1csf090h.bkt.clouddn.com/book/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.jpg)  \nPython进阶书籍。有了一定的python开发基础后就可以看这本书了。主要学习其中的正则表达式，线程和进程，数据库编程，为接下来的Web开发做知识储备。\n## Flask Web开发\n![](http://p1csf090h.bkt.clouddn.com/book/Flask%20Web.jpg)  \n备受好评的Flask学习书籍。每一章都有git tag，跟着作者一步步地完成一个web网站的开发。**注意**：学这本书一定要配合git使用，一步一步的跟着作者敲代码。如果不知道什么是git的可以先去看下廖雪峰的git教程[廖雪峰的git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)。这本书写的很详细，学完基本就对flask比较熟悉了。想要了解更多可以看一下flask的文档，推荐看英文的[Flask英文文档](http://flask.pocoo.org/),如果英语比较差可以看下中文的[Flask中文文档](http://docs.jinkan.org/docs/flask/)，不过最好还是看原文，毕竟翻译作品有时候难以表达作者原意。\n## 数据结构与算法-python语言表述\n![](http://p1csf090h.bkt.clouddn.com/book/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg)  \n这是我最近在看的一本书，本来没看完的书不该推的，但是目前为止感觉很不错，所以也放上来了。。。本书由北大一名老教师编写，所以有一股很浓厚的国内教科书的气息(￣ー￣)不过讲的很详细，也比较好理解，关键是没有《算法导论》那么厚，比较容易让人接受。另一个原因是它是用python作为范例语言讲的，比较方便学习，哈哈  \n**未完待续。。。**\n\n\n','<p>这几天突发奇想，打算把高中毕业以来读过的书整理一遍，做个书单，方便日后查看，也可以给后来者一些参考。因为平时读的书比较杂，所以这份书单里的书也不仅限于一个方向，都是我读过以后觉得还不错的，推荐给大家。  </p>\n<h1>悬疑推理</h1>\n<p>老实说这方面的书我看的不多，印象比较深的就只有东野圭吾写的几本了(～￣▽￣)～ (～￣▽￣)～ </p>\n<h2>白夜行</h2>\n<p><img src=\"http://p1csf090h.bkt.clouddn.com/%E7%99%BD%E5%A4%9C%E8%A1%8C.jpg\" alt=\"\"><br>\n这个不多说，东野的代表作，基本上东野迷人手一本吧。如果你没看过推理小说，或者以前没有接触过东野圭吾，那么从入手这本书不会有错的~</p>\n<h2>解忧杂货店</h2>\n<p><img src=\"http://p1csf090h.bkt.clouddn.com/%E8%A7%A3%E5%BF%A7%E6%9D%82%E8%B4%A7%E5%BA%97.jpg\" alt=\"\"><br>\n东野另一代表作，在日本和国内分别都有翻拍的电影。建议看完书以后有兴趣的话可以看一下日本翻拍的那部电影，至于国产的嘛....如果你是王俊凯的粉丝可以看看￣ω￣=<br>\n说回这本书，书里人物的命运相互交织，冥冥中似乎有一张巨大的网把他们联系在一起：为了躲避抓捕慌乱中躲进杂货店的小贼，被情所困的运动员，为未来彷徨的歌手...我常常会想，自己是否也会像书里说的那样，无意之间改变了他人的命运的走向。毕竟人生在世，没有谁是一座孤岛，再特立独行的人也必定会受到别人的影响。</p>\n<h2>嫌疑人X的献身</h2>\n<p><img src=\"http://p1csf090h.bkt.clouddn.com/book/%E5%AB%8C%E7%96%91%E4%BA%BA.jpg\" alt=\"\"><br>\n如果说刚才两本书着力点在人心，这本书则更注重推理。数学天才为了包庇自己爱的人与警方斗智斗勇的故事。滴水不漏的思维，细致入微的推理，整个故事看下来还是很爽的。毕竟推理小说有点类似于复联这种爽片，能做到人文剧情两不误当然最好，如果不能，单是剧情精彩也就足够了。</p>\n<h1>编程</h1>\n<p>嘿嘿，毕竟这小一年都在学习这方面的知识，所以这方面的书看得会多些￣ω￣=<br>\n学习过程中踩过不少坑，有些书写的水平实在一般，有时自己又太着急了买了些自己还没办法理解的书，有时看完一本书后不知道下一步该怎么办...所以我会按自己的学习路线来给下面的书排版。不过要说明的是，我目前的学习方向是爬虫+后端开发，推荐的书也是以这两方面的居多。当然，现在网上有很多的教学视频，但是视频内容大多不全面，且对我来说视频学习效率不如看书，如果书上有内容看不懂，可以找些相关的视频来看看，有时候会有奇效。</p>\n<h2>C primer plus</h2>\n<p><img src=\"http://p1csf090h.bkt.clouddn.com/book/C%20primer%20plus.jpg\" alt=\"\"><br>\nC入门的经典书籍，C是大部分现代编程语言之母，而且学习C的过程中你还会了解到很多关于计算机底层的知识，所以就算你不准备把C作为主力编程语言，起码也要了解C。这本书说实话挺厚的，不过千万不要被它的厚度吓到了，作为入门我们只需要学习它前半部分的内容，后面的算法知识可以等到以后再补。</p>\n<h2>Python编程-从入门到实战</h2>\n<p><img src=\"http://p1csf090h.bkt.clouddn.com/book/python%E5%85%A5%E9%97%A8.jpg\" alt=\"\"><br>\n很不错的一本Python入门书，基于Python3（要知道python2在2020年就要停止维护了，所以现在入门的话python3是最佳选择）。基本把python基础语法都讲到了，每一个知识点都附有代码实例，章节末尾还有对应的练习。最可贵的是教学节奏把握的不错，学习的时候不会有很无聊的感觉。书末还有3个不错的实战项目，跟着这本书学下来python也就入门了。读完这本书之后如果想进一步加深对python的了解可以看一下廖雪峰老师的Python教程<a href=\"https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000\" rel=\"nofollow\">廖雪峰的python教程</a>。这个教程也是python入门的好资料，不过难度跨越有点大，等有一点python基础之后看效果更好些。</p>\n<h2>图解HTTP</h2>\n<p><img src=\"http://p1csf090h.bkt.clouddn.com/book/%E5%9B%BE%E8%A7%A3http.jpg\" alt=\"\"><br>\n初学HTTP的好书。学习http主要是因为后面的爬虫和web开发都要用到很多http方面的知识。这是一本日本人写的书，风格幽默风趣，最最棒的是书中有大量的插画帮助理解。类似的还有一本书叫《图解TCP/IP》,这里就不单独介绍了。</p>\n<h2>Python爬虫开发与项目实战</h2>\n<p><img src=\"http://p1csf090h.bkt.clouddn.com/book/python%E7%88%AC%E8%99%AB.jpg\" alt=\"\"><br>\n既然已经入门了，当然要称热打铁，找些实际项目来练练手啦，爬虫就是一个很好的练手方向，看着数据一条条地被你从网上抓取下来，会很有成就感的~作为爬虫教程这本书写的很不错，从最基础的爬取静态网页开始，到爬取js渲染的动态网站，再到模拟登陆，处理验证码，反爬...还涉及分布式爬虫的内容。后半部分还对目前最火的python爬虫框架——Scrapy进行了讲解。读完这本书一般的网站都难不住你了。</p>\n<h2>Python核心编程(第三版)</h2>\n<p><img src=\"http://p1csf090h.bkt.clouddn.com/book/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.jpg\" alt=\"\"><br>\nPython进阶书籍。有了一定的python开发基础后就可以看这本书了。主要学习其中的正则表达式，线程和进程，数据库编程，为接下来的Web开发做知识储备。</p>\n<h2>Flask Web开发</h2>\n<p><img src=\"http://p1csf090h.bkt.clouddn.com/book/Flask%20Web.jpg\" alt=\"\"><br>\n备受好评的Flask学习书籍。每一章都有git tag，跟着作者一步步地完成一个web网站的开发。<strong>注意</strong>：学这本书一定要配合git使用，一步一步的跟着作者敲代码。如果不知道什么是git的可以先去看下廖雪峰的git教程<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" rel=\"nofollow\">廖雪峰的git教程</a>。这本书写的很详细，学完基本就对flask比较熟悉了。想要了解更多可以看一下flask的文档，推荐看英文的<a href=\"http://flask.pocoo.org/\" rel=\"nofollow\">Flask英文文档</a>,如果英语比较差可以看下中文的<a href=\"http://docs.jinkan.org/docs/flask/\" rel=\"nofollow\">Flask中文文档</a>，不过最好还是看原文，毕竟翻译作品有时候难以表达作者原意。</p>\n<h2>数据结构与算法-python语言表述</h2>\n<p><img src=\"http://p1csf090h.bkt.clouddn.com/book/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg\" alt=\"\"><br>\n这是我最近在看的一本书，本来没看完的书不该推的，但是目前为止感觉很不错，所以也放上来了。。。本书由北大一名老教师编写，所以有一股很浓厚的国内教科书的气息(￣ー￣)不过讲的很详细，也比较好理解，关键是没有《算法导论》那么厚，比较容易让人接受。另一个原因是它是用python作为范例语言讲的，比较方便学习，哈哈<br>\n<strong>未完待续。。。</strong></p>','2018-04-05 07:21:07'),(11,'《图解HTTP》学习笔记','# TCP/IP与DNS\n## 什么是TCP/IP?\n协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。\n像这样把与互联网相关联的协议集合起来总称为 TCP/IP。HTTP 属于它内部的一个子集。也有说法认为，TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为，TCP/IP 是在 IP 协议的通信过程中，使用到的协议族的统称。\n\n## IP\nIP与IP地址不同。IP是一种网络协议，它的作用是把数据包传给对方。具体是通过MAC地址和ip地址来实现的。  \nMAC地址对应网卡所属的固定地址，ip地址指节点被分配到的地址。IP地址可以与MAC地址对应，IP地址可以换，MAC地址一般是固定的。  \nIP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网\n（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（AddressResolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。\n\n![](http://p1csf090h.bkt.clouddn.com/HTTP/ip.png)\n\n## TCP\n所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可\n靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，\nTCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。\n### TCP的三次握手\nTCP把数据包发出去之后还会确认数据到达了目的地，通过三次握手机制进行确认。  \n发送端发送数据时，TCP会向服务器发送带有SYN标记的数据包，当服务器接收到这个数据包后，会返回一个带有SYN或者ASK的数据包表示确认，最后发送端会再次发送带有ASK标志的数据包表示握手结束。\n\n![](http://p1csf090h.bkt.clouddn.com/HTTP/tcp%E6%8F%A1%E6%89%8B.png)\n## DNS\nDNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如 www.baidu.com。  \n用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。\n为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。\n\n![](http://p1csf090h.bkt.clouddn.com/HTTP/dns.png)\n\n综上，从输入网址到服务器获得请求的过程是：\n\n![](http://p1csf090h.bkt.clouddn.com/HTTP/TCPIP.png)','<h1>TCP/IP与DNS</h1>\n<h2>什么是TCP/IP?</h2>\n<p>协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。\n像这样把与互联网相关联的协议集合起来总称为 TCP/IP。HTTP 属于它内部的一个子集。也有说法认为，TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为，TCP/IP 是在 IP 协议的通信过程中，使用到的协议族的统称。</p>\n<h2>IP</h2>\n<p>IP与IP地址不同。IP是一种网络协议，它的作用是把数据包传给对方。具体是通过MAC地址和ip地址来实现的。<br>\nMAC地址对应网卡所属的固定地址，ip地址指节点被分配到的地址。IP地址可以与MAC地址对应，IP地址可以换，MAC地址一般是固定的。<br>\nIP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网\n（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（AddressResolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p>\n<p><img alt=\"\" src=\"http://p1csf090h.bkt.clouddn.com/HTTP/ip.png\"></p>\n<h2>TCP</h2>\n<p>所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可\n靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，\nTCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。</p>\n<h3>TCP的三次握手</h3>\n<p>TCP把数据包发出去之后还会确认数据到达了目的地，通过三次握手机制进行确认。<br>\n发送端发送数据时，TCP会向服务器发送带有SYN标记的数据包，当服务器接收到这个数据包后，会返回一个带有SYN或者ASK的数据包表示确认，最后发送端会再次发送带有ASK标志的数据包表示握手结束。</p>\n<p><img alt=\"\" src=\"http://p1csf090h.bkt.clouddn.com/HTTP/tcp%E6%8F%A1%E6%89%8B.png\"></p>\n<h2>DNS</h2>\n<p>DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如 <a href=\"http://www.baidu.com\" rel=\"nofollow\">www.baidu.com</a>。<br>\n用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。\n为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。</p>\n<p><img alt=\"\" src=\"http://p1csf090h.bkt.clouddn.com/HTTP/dns.png\"></p>\n<p>综上，从输入网址到服务器获得请求的过程是：</p>\n<p><img alt=\"\" src=\"http://p1csf090h.bkt.clouddn.com/HTTP/TCPIP.png\"></p>\n','2018-04-08 01:42:53');
/*!40000 ALTER TABLE `book` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `photos_s`
--

DROP TABLE IF EXISTS `photos_s`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `photos_s` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `album_id` tinyint(4) DEFAULT NULL,
  `url_s` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `p` (`album_id`)
) ENGINE=InnoDB AUTO_INCREMENT=249 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `photos_s`
--

LOCK TABLES `photos_s` WRITE;
/*!40000 ALTER TABLE `photos_s` DISABLE KEYS */;
INSERT INTO `photos_s` VALUES (217,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\df446409cc.JPG'),(218,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\7b66aa5d4d.JPG'),(219,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\a37fac581e.JPG'),(220,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\95335f17d9.JPG'),(221,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\1b2e311330.jpg'),(222,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\2cb12c211f.jpg'),(223,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\a426338085.jpg'),(224,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\5d459a95d4.jpg'),(225,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\c1c1d76d35.jpg'),(226,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\0ca0d65409.jpg'),(227,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\2268522077.jpg'),(228,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\0b467fb96f.jpg'),(229,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\34a6b82970.jpg'),(230,17,'C:\\Users\\86728\\blog\\app\\static\\Views_s\\91d1e73d1f.jpg'),(231,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\e33f1528cc.jpg'),(232,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\281626c711.jpg'),(233,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\4efc41b9ed.jpg'),(234,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\c2b78e1e6b.jpg'),(235,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\d50c3d801d.jpg'),(236,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\8fad1d78c5.jpg'),(237,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\b44c592ed2.jpg'),(238,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\cfa58d744d.jpg'),(239,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\242bcba0be.jpg'),(240,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\cd64fe0a21.jpg'),(241,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\fb4e8fc5cb.jpg'),(242,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\242b97239f.jpg'),(243,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\5ea317206f.jpg'),(244,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\2227f27c13.jpg'),(245,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\c270e031ca.jpg'),(246,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\8f54192cf6.jpg'),(247,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\724a87cdcb.jpg'),(248,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_s\\35d9f8f6c5.jpg');
/*!40000 ALTER TABLE `photos_s` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `photos_t`
--

DROP TABLE IF EXISTS `photos_t`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `photos_t` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `album_id` tinyint(4) DEFAULT NULL,
  `url_t` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `p` (`album_id`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `photos_t`
--

LOCK TABLES `photos_t` WRITE;
/*!40000 ALTER TABLE `photos_t` DISABLE KEYS */;
INSERT INTO `photos_t` VALUES (25,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_t\\cd64fe0a21.jpg'),(26,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_t\\5ea317206f.jpg'),(27,16,'C:\\Users\\86728\\blog\\app\\static\\FordCar_t\\c270e031ca.jpg'),(28,17,'C:\\Users\\86728\\blog\\app\\static\\Views_t\\c1c1d76d35.jpg'),(29,17,'C:\\Users\\86728\\blog\\app\\static\\Views_t\\0ca0d65409.jpg'),(30,17,'C:\\Users\\86728\\blog\\app\\static\\Views_t\\2268522077.jpg');
/*!40000 ALTER TABLE `photos_t` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `python`
--

DROP TABLE IF EXISTS `python`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `python` (
  `id` tinyint(4) NOT NULL AUTO_INCREMENT,
  `title` varchar(64) NOT NULL,
  `body` longtext,
  `body_html` longtext,
  `timestamp` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `python`
--

LOCK TABLES `python` WRITE;
/*!40000 ALTER TABLE `python` DISABLE KEYS */;
INSERT INTO `python` VALUES (1,'python杂谈','## 面向对象编程（OOP）\n### 方法与函数\n面向对象编程思想中，方法是指一个对象可以使用的函数，举个例子\n```python\narr = [1,2,3]\narr.remove(2)\n```\narr被定义为指向列表对象的变量，而remove则是list对象的一个方法，用于从列表中删除某个值。  \n而函数则是对对象进行操作，例如\n```python\narr = [1,2,3]\nlen(arr)\n```\nlen()函数对其参数求长度。在本例中len()的参数既是一个列表。\n### 一切皆对象\npython一个很出名的特性是一切皆对象。比如变量，类，甚至函数也可以作为一个对象传给变量。比如：\n```python\ndef plus(x,y):\n    return x+y\nplus(1,3)\n\nfrom threading import Threat\n\nif __name__ == \'__main__\':\n    t = Threat(target=plus,args=(1,3,))\n    t.start()\n    t.join()\n```\n第八行的target参数传入的是plus函数的对象，此时不需要括号。而第三行的plus()加了括号是告诉python解释器执行这个函数对象。\n## python常用的装饰器\npython中的装饰器可以对函数进行扩展。\n### @property\n**@property装饰器可以把类的方法变成属性**。例如\n```python\nclass Student():\n    def __init__(self,score):\n        self.score = score\n\n#调用Student类\nqiuyue = Student(90)\nprint(qiuyue.score) #输出结果90\n```\n可是这样也不无问题，比如当输入分数不合理（如1000）时，无法对分数进行检查。当然，可以对Student类附加方法实现检查分数。\n```python\nclass Student():\n    def get_score(self):\n        return self._score\n\n    def set_score(self,value):\n        if not isinstance(score,int):\n            raise ValueError(\'score must is an integer!\')\n        if value > 100 or value < 0:\n            raise ValueError(\'score must between 0 to 100!\')\n        self._score = value\n\n#调用Student类\nqiuyue = Student()\nqiuyue.set_score(90)\nprint(qiuyue.get_score()) #输出90        \n```\n通过set方法对Student的score属性赋值，再用get方法获取score属性。这样就可以实现对score合法性的检查。但是为了一个属性特地写两个方法未免过于繁琐。所以用到装饰器@property封装set方法和get方法，实现对score属性赋值的同时进行数值合法性检查。\n\n```python\nclass Student():\n    @property\n    def score(self)\n        return self._score\n\n    @score.setter\n    def score(self,value)\n        if not isinstance(value,int):\n            raise ValueError(\'score must is an integer!\')\n        if value > 100 or value < 0:\n            raise ValueError(\'score must between 0 to 100!\')    \n        self._score = value\n\n    @property\n    def grade(self):\n        if self._score is None:\n            return None\n        elif self._score >= 90:\n            print(\'优秀！\')\n        elif self._score >=60:\n            print(\'及格！)\n        else:\n            print(\'不及格！\')\n\n#调用Student类\nqiuyue = Student()\nqiuyue.score = 90\nprint(qiuyue.score) # 输出90\nqiuyue.score = 1000 # 报错，ValueError\nqiuyue.grade = \'及格\' # 报错\nqiuyue.grade # 输出优秀\n```\n可以看到，@property装饰的第一个score，实际上是一个get方法，而@score.setter装饰的第二个score实际上是set方法。@score.setter其实是@property装饰器的副产品。这两个装饰器一个装饰get方法，一个装饰set方法，这样就使score方法变成了Student类的属性，在对score属性赋值（即set方法）时会自动对值的合法性进行检查，调用score属性即调用get方法。  \n@grade.setter并不是必须的，当缺少@grade.setter装饰器时grade属性变成只读属性，无法对其进行赋值，只能读取。\n### @classmethod与@staticmethod\n在介绍类方法@classmethod与静态方法staticmethod前，先要清楚一个概念：类属性与实例属性是**不同**的。\n```python\nclass Plus():\n    num = 1\n\nf = Plus()\nf.num = 2\n\nprint(Plus.num) # 结果为2    \nprint(f.num) # 结果为1\n```\n众所周知，要调用类的方法，我们首先要把这个类实例化，然后通过*实例名.方法名*的方式调用。而@classmethod与@staticmethod都可以实现通过*类名.方法名*的方式调用方法。\n#### @classmethod\n当类中有些方法不需要涉及实例，而需要涉及类，如对类属性的修改，往往使用@classmethod。用@classmethod修饰的方法不会将实例传入方法中，而会自动将自身类作为第一个参数传入。所以这个方法不需要写self参数，但需要一个cls参数代表这个类。  \n```python\nclass Apple():\n    apple = 1\n    @classmethod\n    def how_much(cls):\n        if cls.app == 1:\n            print(\'还有一个苹果\')\n\nApple.how_much() # 输出：还有一个苹果\n```\n#### @staticmethod\n如果类中有些方法既不涉及类，也不涉及实例，可以用@staticmethod。@staticmethod既不会将实例传入方法，也不会将自身类传入方法。所以既没有self参数也没有cls参数。  \n```python\nclass Apple():\n    apple = 1\n    def change(self,data):\n        self.apple = data\n        print(\'还有%s个苹果\' % self.apple)\n\n    @staticmethod\n    def how_much():\n        print(\'没有苹果了\')\n\napple = Apple()\napple.change(2) # 输出：还有2个苹果\nApple.how_much() # 输出： 没有苹果了\n```\n下面这个例子加深区分：\n```python\nclass Apple():\n    num = 1\n    def __init__(self,data):\n        self.num = data\n\n    def common(self):\n        print(\'还有%s个苹果\' % self.num)\n\n    @classmethod\n    def clsmed(cls):\n        print(\'还有%s个苹果\' % cls.num)\n\n    @staticmethod\n    def stamed():\n        print(\'没有苹果了\')\n\napple = Apple(2)\napple.common() # 输出：还有2个苹果\nApple.clsmed() # 输出：还有1个苹果\nApple.stamed() # 输出：没有苹果了\n```\n## Python的特点\n像java，C#这种编译型语言，会将代码编译成二进制再运行。而python作为一种解释型语言，是**动态的逐行解释代码**的，也就是从脚本第一行开始，没有统一的入口。一个Python源码文件除了可以被直接执行外，还可以作为模块（也就是库）被其他.py文件导入。此时这个源码文件的文件名（不包括.py）就是库名。  \npython本身有很多有趣的方法，会在每一个python文件里自动生成，在特殊情况下还会自动调用，这种方法称之为魔法方法。魔法方法的形式为两个下划线(\\_\\_)+方法名+两个下划线(\\_\\_)。如：\\_\\_new\\_\\_。下面介绍一些常见的魔法方法。  \n### \\_\\_file__\n通过下面一行代码，就能很直接地看出\\_\\_file__的作用。  \n```python\n# 文件位置为E:/python/test.py\nprint(__file__)\n# 输出E:/python/test.py\n```\n可见，_\\_file\\_\\_代表了当前python文件的路径。而且如前面所言，这个方法是python自动实现的，不需要你去编写。  \n### \\_\\_name__\n相信不少python初学者都见到过这样一段代码：\n```python\nif __name__ == \"__main__\":\n    app.run()\n```\n可能很多人第一次看到这段代码的时候都会困惑：这个\\_\\_main\\_\\_我理解，是主函数的意思，可是这\\_\\_name\\_\\_是个什么东东？老规矩，上一段代码:\n```python\n# 文件位置为E:/python/test.py\nprint(__name__)\n# 输出__main__\n```\njava，C等语言都会显示地定义一个main()函数，一个用C编写的程序都是以main()作为程序入口的。而python不同，哪个文件被直接执行，哪个文件的模块名就是\\_\\_main\\_\\_。现在说回\\_\\_name\\_\\_, \\_\\_name\\_\\_存放的就是当前python文件的名字，那么现在情况就很明显了，开头那段代码的意思是：如果这个文件是被直接运行的，就执行app.run()，如果这个文件是被别的文件导入后运行的，就会跳过app.run()。这样做的好处是避免了一些只能在主程序里执行的代码由于被导入了其他文件而错误执行。\n## requirements.txt\n在查看别人的python项目时，常会见到一个requirements.txt文件，主要是说明这个项目依赖的模块及其版本。我们可以用这个命令生成requirements.txt文件：\n```\npip freeze > requirements.txt\n```\n要导入这个文件里指出的模块也很简单，只要用:\n```\npip install -r requirements.txt\n```\n## is与==的区别\n写代码的时候常常用is和==来比较两个对象是否相等，但是它们有什么不同呢？参考下面的例子：\n```python\na = 1\nb = 1\na == b # True\na is b # True\n\na = 888\nb = 888\na == b # True\na is b # False\n\na = \'hello\'\nb = \'hello\'\na is b # True\na == b # True\n\na = \'hello world\'\nb = \'hello world\'\na == b # True\na is b # False\n```\n奇怪真奇怪！is和==的结果不同！不是说好的都是比较两个对象是否相等吗？怎么到这里变了样了？不急，先介绍一下python内置的一个函数：id()，这个函数会打印参数的内存地址，让我们来试试：\n```python\na = 888\nb = 888\nid(a) # 1939743592336\nid(b) # 1939745557808\n\na = \'hello world\'\nb = \'hello world\'\nid(a) # 1939745897200\nid(b) # 1939745912624\n```\n可以看到，尽管a、b的值是相同的，但是其内存地址却不同。那么答案就很显然了，**is比较的是两个对象的内存地址是否相等，==比较的是两个对象的值是否相等**。这样就能解释为什么is和==的结果不同了。But wait，那么为什么当a、b的值为1和\'hello\'时，is与==的结果是一样的呢？这就要说到python的小整数池和垃圾回收机制了。python为了让运行速度快些，在内存中专门开辟了一块区域放置0到256，所有代表0到256的对象都会指向这个区域。类似的，python为短文本也开辟了这样的一块内存空间。所以这时is和==会得到相同的结果：\n```python\na = 1\nb = 1\nid(a) # 1963327952\nid(b) # 1963327952\n\na = \'hello\' \nb = \'hello\' \nid(a) # 1939745887600\nid(b) # 1939745887600 \n```','<h2>面向对象编程（OOP）</h2>\n<h3>方法与函数</h3>\n<p>面向对象编程思想中，方法是指一个对象可以使用的函数，举个例子</p>\n<div class=\"highlight\"><pre><span></span><span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">]</span>\n<span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre></div>\n<p>arr被定义为指向列表对象的变量，而remove则是list对象的一个方法，用于从列表中删除某个值。<br>\n而函数则是对对象进行操作，例如</p>\n<div class=\"highlight\"><pre><span></span><span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">]</span>\n<span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">)</span>\n</pre></div>\n<p>len()函数对其参数求长度。在本例中len()的参数既是一个列表。</p>\n<h3>一切皆对象</h3>\n<p>python一个很出名的特性是一切皆对象。比如变量，类，甚至函数也可以作为一个对象传给变量。比如：</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">def</span> <span class=\"nf\">plus</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"o\">+</span><span class=\"n\">y</span>\n<span class=\"n\">plus</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">threading</span> <span class=\"kn\">import</span> <span class=\"n\">Threat</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;__main__&#39;</span><span class=\"p\">:</span>\n    <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">Threat</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"n\">plus</span><span class=\"p\">,</span><span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,))</span>\n    <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n    <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">()</span>\n</pre></div>\n<p>第八行的target参数传入的是plus函数的对象，此时不需要括号。而第三行的plus()加了括号是告诉python解释器执行这个函数对象。</p>\n<h2>python常用的装饰器</h2>\n<p>python中的装饰器可以对函数进行扩展。</p>\n<h3>@property</h3>\n<p><strong>@property装饰器可以把类的方法变成属性</strong>。例如</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Student</span><span class=\"p\">():</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"n\">score</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">score</span> <span class=\"o\">=</span> <span class=\"n\">score</span>\n\n<span class=\"c1\">#调用Student类</span>\n<span class=\"n\">qiuyue</span> <span class=\"o\">=</span> <span class=\"n\">Student</span><span class=\"p\">(</span><span class=\"mi\">90</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">qiuyue</span><span class=\"o\">.</span><span class=\"n\">score</span><span class=\"p\">)</span> <span class=\"c1\">#输出结果90</span>\n</pre></div>\n<p>可是这样也不无问题，比如当输入分数不合理（如1000）时，无法对分数进行检查。当然，可以对Student类附加方法实现检查分数。</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Student</span><span class=\"p\">():</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_score</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_score</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">set_score</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"n\">value</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">score</span><span class=\"p\">,</span><span class=\"nb\">int</span><span class=\"p\">):</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">&#39;score must is an integer!&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"o\">&gt;</span> <span class=\"mi\">100</span> <span class=\"ow\">or</span> <span class=\"n\">value</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">&#39;score must between 0 to 100!&#39;</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_score</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n\n<span class=\"c1\">#调用Student类</span>\n<span class=\"n\">qiuyue</span> <span class=\"o\">=</span> <span class=\"n\">Student</span><span class=\"p\">()</span>\n<span class=\"n\">qiuyue</span><span class=\"o\">.</span><span class=\"n\">set_score</span><span class=\"p\">(</span><span class=\"mi\">90</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">qiuyue</span><span class=\"o\">.</span><span class=\"n\">get_score</span><span class=\"p\">())</span> <span class=\"c1\">#输出90</span>\n</pre></div>\n<p>通过set方法对Student的score属性赋值，再用get方法获取score属性。这样就可以实现对score合法性的检查。但是为了一个属性特地写两个方法未免过于繁琐。所以用到装饰器@property封装set方法和get方法，实现对score属性赋值的同时进行数值合法性检查。</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Student</span><span class=\"p\">():</span>\n    <span class=\"nd\">@property</span>\n    <span class=\"k\">def</span> <span class=\"nf\">score</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_score</span>\n\n    <span class=\"nd\">@score.setter</span>\n    <span class=\"k\">def</span> <span class=\"nf\">score</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span><span class=\"nb\">int</span><span class=\"p\">):</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">&#39;score must is an integer!&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"o\">&gt;</span> <span class=\"mi\">100</span> <span class=\"ow\">or</span> <span class=\"n\">value</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">&#39;score must between 0 to 100!&#39;</span><span class=\"p\">)</span>    \n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_score</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n\n    <span class=\"nd\">@property</span>\n    <span class=\"k\">def</span> <span class=\"nf\">grade</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_score</span> <span class=\"ow\">is</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">None</span>\n        <span class=\"k\">elif</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_score</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">90</span><span class=\"p\">:</span>\n            <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;优秀！&#39;</span><span class=\"p\">)</span>\n        <span class=\"k\">elif</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">_score</span> <span class=\"o\">&gt;=</span><span class=\"mi\">60</span><span class=\"p\">:</span>\n            <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;及格！)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;不及格！&#39;</span><span class=\"p\">)</span>\n\n<span class=\"c1\">#调用Student类</span>\n<span class=\"n\">qiuyue</span> <span class=\"o\">=</span> <span class=\"n\">Student</span><span class=\"p\">()</span>\n<span class=\"n\">qiuyue</span><span class=\"o\">.</span><span class=\"n\">score</span> <span class=\"o\">=</span> <span class=\"mi\">90</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">qiuyue</span><span class=\"o\">.</span><span class=\"n\">score</span><span class=\"p\">)</span> <span class=\"c1\"># 输出90</span>\n<span class=\"n\">qiuyue</span><span class=\"o\">.</span><span class=\"n\">score</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span> <span class=\"c1\"># 报错，ValueError</span>\n<span class=\"n\">qiuyue</span><span class=\"o\">.</span><span class=\"n\">grade</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;及格&#39;</span> <span class=\"c1\"># 报错</span>\n<span class=\"n\">qiuyue</span><span class=\"o\">.</span><span class=\"n\">grade</span> <span class=\"c1\"># 输出优秀</span>\n</pre></div>\n<p>可以看到，@property装饰的第一个score，实际上是一个get方法，而@score.setter装饰的第二个score实际上是set方法。@score.setter其实是@property装饰器的副产品。这两个装饰器一个装饰get方法，一个装饰set方法，这样就使score方法变成了Student类的属性，在对score属性赋值（即set方法）时会自动对值的合法性进行检查，调用score属性即调用get方法。<br>\n@grade.setter并不是必须的，当缺少@grade.setter装饰器时grade属性变成只读属性，无法对其进行赋值，只能读取。</p>\n<h3>@classmethod与@staticmethod</h3>\n<p>在介绍类方法@classmethod与静态方法staticmethod前，先要清楚一个概念：类属性与实例属性是<strong>不同</strong>的。</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Plus</span><span class=\"p\">():</span>\n    <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">Plus</span><span class=\"p\">()</span>\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">Plus</span><span class=\"o\">.</span><span class=\"n\">num</span><span class=\"p\">)</span> <span class=\"c1\"># 结果为2    </span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">num</span><span class=\"p\">)</span> <span class=\"c1\"># 结果为1</span>\n</pre></div>\n<p>众所周知，要调用类的方法，我们首先要把这个类实例化，然后通过<em>实例名.方法名</em>的方式调用。而@classmethod与@staticmethod都可以实现通过<em>类名.方法名</em>的方式调用方法。</p>\n<h4>@classmethod</h4>\n<p>当类中有些方法不需要涉及实例，而需要涉及类，如对类属性的修改，往往使用@classmethod。用@classmethod修饰的方法不会将实例传入方法中，而会自动将自身类作为第一个参数传入。所以这个方法不需要写self参数，但需要一个cls参数代表这个类。</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Apple</span><span class=\"p\">():</span>\n    <span class=\"n\">apple</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">how_much</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">app</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;还有一个苹果&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">Apple</span><span class=\"o\">.</span><span class=\"n\">how_much</span><span class=\"p\">()</span> <span class=\"c1\"># 输出：还有一个苹果</span>\n</pre></div>\n<h4>@staticmethod</h4>\n<p>如果类中有些方法既不涉及类，也不涉及实例，可以用@staticmethod。@staticmethod既不会将实例传入方法，也不会将自身类传入方法。所以既没有self参数也没有cls参数。</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Apple</span><span class=\"p\">():</span>\n    <span class=\"n\">apple</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">def</span> <span class=\"nf\">change</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">apple</span> <span class=\"o\">=</span> <span class=\"n\">data</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;还有</span><span class=\"si\">%s</span><span class=\"s1\">个苹果&#39;</span> <span class=\"o\">%</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">apple</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">how_much</span><span class=\"p\">():</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;没有苹果了&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">apple</span> <span class=\"o\">=</span> <span class=\"n\">Apple</span><span class=\"p\">()</span>\n<span class=\"n\">apple</span><span class=\"o\">.</span><span class=\"n\">change</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"c1\"># 输出：还有2个苹果</span>\n<span class=\"n\">Apple</span><span class=\"o\">.</span><span class=\"n\">how_much</span><span class=\"p\">()</span> <span class=\"c1\"># 输出： 没有苹果了</span>\n</pre></div>\n<p>下面这个例子加深区分：</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">class</span> <span class=\"nc\">Apple</span><span class=\"p\">():</span>\n    <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"n\">data</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">common</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;还有</span><span class=\"si\">%s</span><span class=\"s1\">个苹果&#39;</span> <span class=\"o\">%</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@classmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">clsmed</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">):</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;还有</span><span class=\"si\">%s</span><span class=\"s1\">个苹果&#39;</span> <span class=\"o\">%</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">num</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">stamed</span><span class=\"p\">():</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;没有苹果了&#39;</span><span class=\"p\">)</span>\n\n<span class=\"n\">apple</span> <span class=\"o\">=</span> <span class=\"n\">Apple</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">apple</span><span class=\"o\">.</span><span class=\"n\">common</span><span class=\"p\">()</span> <span class=\"c1\"># 输出：还有2个苹果</span>\n<span class=\"n\">Apple</span><span class=\"o\">.</span><span class=\"n\">clsmed</span><span class=\"p\">()</span> <span class=\"c1\"># 输出：还有1个苹果</span>\n<span class=\"n\">Apple</span><span class=\"o\">.</span><span class=\"n\">stamed</span><span class=\"p\">()</span> <span class=\"c1\"># 输出：没有苹果了</span>\n</pre></div>\n<h2>Python的特点</h2>\n<p>像java，C#这种编译型语言，会将代码编译成二进制再运行。而python作为一种解释型语言，是<strong>动态的逐行解释代码</strong>的，也就是从脚本第一行开始，没有统一的入口。一个Python源码文件除了可以被直接执行外，还可以作为模块（也就是库）被其他.py文件导入。此时这个源码文件的文件名（不包括.py）就是库名。<br>\npython本身有很多有趣的方法，会在每一个python文件里自动生成，在特殊情况下还会自动调用，这种方法称之为魔法方法。魔法方法的形式为两个下划线(__)+方法名+两个下划线(__)。如：__new__。下面介绍一些常见的魔法方法。</p>\n<h3>__file__</h3>\n<p>通过下面一行代码，就能很直接地看出__file__的作用。</p>\n<div class=\"highlight\"><pre><span></span><span class=\"c1\"># 文件位置为E:/python/test.py</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">)</span>\n<span class=\"c1\"># 输出E:/python/test.py</span>\n</pre></div>\n<p>可见，__file__代表了当前python文件的路径。而且如前面所言，这个方法是python自动实现的，不需要你去编写。</p>\n<h3>__name__</h3>\n<p>相信不少python初学者都见到过这样一段代码：</p>\n<div class=\"highlight\"><pre><span></span><span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">&quot;__main__&quot;</span><span class=\"p\">:</span>\n    <span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre></div>\n<p>可能很多人第一次看到这段代码的时候都会困惑：这个__main__我理解，是主函数的意思，可是这__name__是个什么东东？老规矩，上一段代码:</p>\n<div class=\"highlight\"><pre><span></span><span class=\"c1\"># 文件位置为E:/python/test.py</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"vm\">__name__</span><span class=\"p\">)</span>\n<span class=\"c1\"># 输出__main__</span>\n</pre></div>\n<p>java，C等语言都会显示地定义一个main()函数，一个用C编写的程序都是以main()作为程序入口的。而python不同，哪个文件被直接执行，哪个文件的模块名就是__main__。现在说回__name__, __name__存放的就是当前python文件的名字，那么现在情况就很明显了，开头那段代码的意思是：如果这个文件是被直接运行的，就执行app.run()，如果这个文件是被别的文件导入后运行的，就会跳过app.run()。这样做的好处是避免了一些只能在主程序里执行的代码由于被导入了其他文件而错误执行。</p>\n<h2>requirements.txt</h2>\n<p>在查看别人的python项目时，常会见到一个requirements.txt文件，主要是说明这个项目依赖的模块及其版本。我们可以用这个命令生成requirements.txt文件：</p>\n\n<pre><code>pip freeze &gt; requirements.txt</code></pre>\n<p>要导入这个文件里指出的模块也很简单，只要用:</p>\n\n<pre><code>pip install -r requirements.txt</code></pre>\n<h2>is与==的区别</h2>\n<p>写代码的时候常常用is和==来比较两个对象是否相等，但是它们有什么不同呢？参考下面的例子：</p>\n<div class=\"highlight\"><pre><span></span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">a</span> <span class=\"o\">==</span> <span class=\"n\">b</span> <span class=\"c1\"># True</span>\n<span class=\"n\">a</span> <span class=\"ow\">is</span> <span class=\"n\">b</span> <span class=\"c1\"># True</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">888</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">888</span>\n<span class=\"n\">a</span> <span class=\"o\">==</span> <span class=\"n\">b</span> <span class=\"c1\"># True</span>\n<span class=\"n\">a</span> <span class=\"ow\">is</span> <span class=\"n\">b</span> <span class=\"c1\"># False</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;hello&#39;</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;hello&#39;</span>\n<span class=\"n\">a</span> <span class=\"ow\">is</span> <span class=\"n\">b</span> <span class=\"c1\"># True</span>\n<span class=\"n\">a</span> <span class=\"o\">==</span> <span class=\"n\">b</span> <span class=\"c1\"># True</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;hello world&#39;</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;hello world&#39;</span>\n<span class=\"n\">a</span> <span class=\"o\">==</span> <span class=\"n\">b</span> <span class=\"c1\"># True</span>\n<span class=\"n\">a</span> <span class=\"ow\">is</span> <span class=\"n\">b</span> <span class=\"c1\"># False</span>\n</pre></div>\n<p>奇怪真奇怪！is和==的结果不同！不是说好的都是比较两个对象是否相等吗？怎么到这里变了样了？不急，先介绍一下python内置的一个函数：id()，这个函数会打印参数的内存地址，让我们来试试：</p>\n<div class=\"highlight\"><pre><span></span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">888</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">888</span>\n<span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"c1\"># 1939743592336</span>\n<span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"c1\"># 1939745557808</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;hello world&#39;</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;hello world&#39;</span>\n<span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"c1\"># 1939745897200</span>\n<span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"c1\"># 1939745912624</span>\n</pre></div>\n<p>可以看到，尽管a、b的值是相同的，但是其内存地址却不同。那么答案就很显然了，<strong>is比较的是两个对象的内存地址是否相等，==比较的是两个对象的值是否相等</strong>。这样就能解释为什么is和==的结果不同了。But wait，那么为什么当a、b的值为1和\'hello\'时，is与==的结果是一样的呢？这就要说到python的小整数池和垃圾回收机制了。python为了让运行速度快些，在内存中专门开辟了一块区域放置0到256，所有代表0到256的对象都会指向这个区域。类似的，python为短文本也开辟了这样的一块内存空间。所以这时is和==会得到相同的结果：</p>\n<div class=\"highlight\"><pre><span></span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"c1\"># 1963327952</span>\n<span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"c1\"># 1963327952</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;hello&#39;</span> \n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;hello&#39;</span> \n<span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span> <span class=\"c1\"># 1939745887600</span>\n<span class=\"nb\">id</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"c1\"># 1939745887600</span>\n</pre></div>\n','2018-04-07 07:51:17'),(2,'进程与线程','# 什么是进程/线程\n众所周知，CPU是计算机的核心，它承担了所有的计算任务。而操作系统是计算机的管理者，是一个大管家，它负责任务的调度，资源的分配和管理，统领整个计算机硬件。应用应用程序是具有某种功能的程序，程序运行与操作系统之上。\n## 进程\n进程时一个具有一定功能的程序在一个数据集上的一次动态执行过程。进程由程序，数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时需要的数据和工作区；程序控制块（PCB）包含程序的描述信息和控制信息，是进程存在的唯一标志。  \n## 线程\n在很早的时候计算机并没有线程这个概念，但是随着时代的发展，只用进程来处理程序出现很多的不足。如当一个进程堵塞时，整个程序会停止在堵塞处，并且如果频繁的切换进程，会浪费系统资源。所以线程出现了。  \n线程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。一个进程可以拥有多个线程，而且属于同一个进程的多个线程间会共享该进行的资源。\n## 进程与线程的区别\n1. 一个进程由一个或者多个线程组成，线程是一个进程中代码的不同执行路线。\n2. 切换进程需要的资源比切换线程的要多的多。\n3. 进程之间相互独立，而同一个进程下的线程共享程序的内存空间（如代码段，数据集，堆栈等）。某进程内的线程在其他进程不可见。换言之，线程共享同一片内存空间，而进程各有独立的内存空间。\n以下是作者在知乎上看到的关于进程与线程的讨论，其中一个作者感觉很有道理，摘抄如下：\n> 作者：zhonyong\n链接：https://www.zhihu.com/question/25532384/answer/81152571\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  \n\n\n> 首先来一句概括的总论：进程和线程都是一个时间段的描述，是CPU工作时间段的描述。下面细说背景：CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。一个必须知道的事实：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。  \n========= 重要的东西出现了========  \n进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文线程是什么呢？进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。到此全文结束，再一个总结：进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。  \n\n# 开进程需要时间\n学习《python爬虫开发与项目实践》时，执行下面一段代码：\n```python\nfrom multiprocessing import Process\nimport os\n\ndef run_process(name):\n    print(\"Child process %s (%s) is running\" % (name,os.getpid()))\n\nif __name__ == \"__main__\":\n    print(\"parant process %s \" % os.getpid())\n    for i in range(5):\n        p = Process(target=run_process, args=(str(i),))\n        print(\"process will start\")\n        p.start()\n    p.join()\n    print(\"process end\")  \n```\n显示的结果是\n```\nparant process 6332 \nprocess will start\nprocess will start\nprocess will start\nprocess will start\nprocess will start\nChild process 2 (9896) is running\nChild process 0 (11208) is running\nChild process 3 (5464) is running\nChild process 1 (10208) is running\nChild process 4 (12596) is running\nprocess end\n```\n可以看到，程序在执行完\n```\nprint (\"parant process %s \" % os.getpid())\n```\n没有接着马上执行run_process()，而是先打印process will start，最后把子进程一起执行。这是因为子进程的创建是需要时间的，在这个空闲时间里父进程继续执行代码，而子进程在创建完成后显示。    \n\n# Pool进程池\n需要创建多个进程时，可以使用multiprocessing中的Pool类开进程池。Pool()默认开启数量等于当前cpu核心数的子进程（当然可以手动改变）\n```python\nfrom multiprocessing import Pool\n\ndef hello(i):\n    print(\"hello ,this is the %d process\" % i)\n\ndef main():\n    p = Pool()\n    for i in range(1,5):\n        p.apply_async(target=hell0,args=(i,))\n    p.close    \n    p.join\n\nif __name__ == \"__main__\":\n    main()\n```\napply_async表示在开进程时不阻塞主进程，是异步IO的一种方式之一。targe参数传入要在子线程中执行的**函数对象**，args以元组的方式传入函数的参数。  \njoin会等待线程池中的每一个线程执行完毕，在调用join之前必须要先调用close，close表示不能再向线程池中添加新的process了。\n# 进程间的通信\n每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。假如创建了多个进程，那么进程间的通信是必不可少的。Python提供了多种进程通信的方式，其中以Queue和Pipe用得最多。下面分别介绍这两种模式。\n## Queue\nQueue是一种**多进程**安全的队列。实现多进程间的通信有两种方法：\n- get() 用于向队列中加入数据。有两个属性：blocked和timeout。blocked为true时（默认为True）且timeout为正值时，如果当队列已满会阻塞timeout时间，在这个时间内如果队列有空位会加入，如果超过时间仍然没有空位会抛出Queue.Full异常。\n- put() 用于从队列中获取一个数据并将其从队列中删除。有两个属性：blocked和timeout。blocked为true（默认为True）且timeout为正值时，如果当前队列为空会阻塞timeout时间，在这个时间内如果队列有新数据会获取，如果超过时间仍然没有新数据会抛出Queue.Empty异常。\n```python\nfrom multiprocessing import Process,Queue\nimport os\n\ndef put_data(q,nums):\n    print(\'现在的进程编号为：%s，这是一个put进程\' % os.getpid())\n    for num in nums:\n        q.put(num)\n        print(\'%d已经放入队列中啦！\' % num)\n\ndef get_data(q):\n    print(\'现在的进程编号为：%s，这是一个get进程\' % os.getpid())\n    while True:\n        print(\'已经从队列中获取%s并从中删除\' % q.get())\n\nif __name__ == \'__main__\':\n    q = Queue()\n    p1 = Process(target=put_data,args=(q,[\'1\',\'2\',\'3\'],))\n    p2 = Process(target=put_data,args=(q,[\'4\',\'5\',\'6\'],))\n    p3 = Process(target=get_data,args=(q,))\n    p1.start()\n    p2.start()\n    p3.start()\n    p1.join()\n    p2.join()\n    # p3是个死循环，需要手动结束这个进程\n    p3.terminate()\n```\n我们来看一下运行结果：\n```\n现在的进程编号为：10336，这是一个put进程\n1已经放入队列中啦！\n2已经放入队列中啦！\n3已经放入队列中啦！\n现在的进程编号为：9116，这是一个get进程\n已经从队列中获取1,并从中删除\n已经从队列中获取2并从中删除\n已经从队列中获取3并从中删除\n现在的进程编号为：2732，这是一个put进程\n4已经放入队列中啦！\n5已经放入队列中啦！\n已经从队列中获取4,并从中删除\n6已经放入队列中啦！\n已经从队列中获取5并从中删除\n已经从队列中获取6并从中删除\n```\n## Pipe\nPipe与Queue不同之处在于Pipe是用于**两个进程**之间的通信。就像进程位于一根水管的两端。让我们看看Pipe官方文档的描述：  \n> Returns a pair (conn1, conn2) of Connection objects representing the ends of a pipe.\n\nPiep返回conn1和conn2代表水管的两端。Pipe还有一个参数duplex（adj. 二倍的，双重的 n. 双工；占两层楼的公寓套房），默认为True。当duplex为True时，开启双工模式，此时水管的两边都可以进行收发。当duplex为False，那么**conn1只负责接受信息，conn2只负责发送信息。**  \nconn通过send()和recv()来发送和接受信息。值得注意的是，如果管道中没有信息可接受，recv()会一直阻塞直到管道关闭（任意一端进程接结束则管道关闭）。\n```python\nfrom multiprocessing import Process,Pipe\nimport os\n\ndef put_data(p,nums):\n    print(\'现在的进程编号为：%s，这个一个send进程\' % os.getpid())\n    for num in nums:\n        p.send(num)\n        print(\'%s已经放入管道中啦！\' % num)\n\ndef get_data(p):\n    print(\'现在的进程编号为：%s，这个一个recv进程\' % os.getpid())\n    while True:\n        print(\'已经从管道中获取%s并从中删除\' % p.recv())\n\nif __name__ == \'__main__\':\n    p = Pipe(duplex=False)\n    # 此时Pipe[1]即是Pipe返回的conn2\n    p1 = Process(target=put_data,args=(p[1],[\'1\',\'2\',\'3\'],))\n    # 此时Pipe[0]即是Pipe返回的conn1\n    p3 = Process(target=get_data,args=(p[0],))\n    p1.start()\n    p3.start()\n    p1.join()\n    p3.terminate()\n```\n让我们看一下输出结果\n```\n现在的进程编号为：9868，这个一个recv进程\n现在的进程编号为：9072，这个一个send进程\n1已经放入管道中啦！\n已经从管道中获取1,并从中删除\n2已经放入管道中啦！\n已经从管道中获取2并从中删除\n3已经放入管道中啦！\n已经从管道中获取3并从中删除\n```\n# 控制线程\n我们是没有办法完全人为控制线程的，因为线程由系统控制。但是可以用一些方式来影响线程的调用，比如互斥锁，sleep（阻塞），死锁等。\n\n## 线程的几种状态\n新建-----就绪------------------运行-----死亡  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待（阻塞）  \n线程的生命周期由run方法决定，当run方法结束时线程死亡。可以通过继承Thread，重写run方法改变Thread的功能，最后还是通过start()方法开线程。  \n```python\nfrom threading import Thread\n\nclass MyThread(Thread):\n    def run(self):\n        print(\'i am sorry\')\n\nif __name__ == \'__main__\':\n    t = MyThread()\n    t.start()\n```  \n通过args参数以一个元组的方式给线程中的函数传参。   \n\n```python\nfrom threading import Thread\n\ndef sorry(name):\n    print(\'i am sorry\',name)\n\nif __name__ == \'__main__\':  \n    t = Thread(target=sorry,args=(\'mike\'))\n    t.start()\n```\n## 线程锁\n多线程中任务中，可能会发生多个线程同时对一个公共资源（如全局变量）进行操作的情况，这是就会发生混乱。为了避免这种情况，需要引入线程锁的概念。只有一个线程能处于上锁状态，当一个线程上锁之后，如果有另外一个线程试图获得锁，该线程就会挂起直到拥有锁的线程将锁释放。这样就保证了同时只有一个线程对公共资源进行访问或修改。  \n```python\nfrom threading import Thread,Lock\n\nnum = 0\ndef puls():\n    # 获得一个锁\n    lock = Lock()\n    global num\n    # acquire()方法上锁\n    lock.acquire()\n    num += 1\n    print(num)\n    # release()方法解锁\n    lock.release()\n\nif __name__ == \'__main__\':\n    for i in range(5):\n        t = Thread(target=plus)\n        t.start()\n    t.join()     \n```\njoin()方法会阻塞主线程直到子线程全部结束（也就是同步）。  \n<br>\n锁的用处:\n1. 确保某段关键代码只能由一个线程从头到尾执行，保证了数据的唯一性。  \n\n锁的坏处:  \n1. 阻止了多线程并发执行，效率大大降低。\n2. 由于存在多个锁，不同的线程持有不同的锁并试图获取对方的锁时，可能造成死锁。  \n\n# 守护线程\n线程其实并没有主次的概念，我们一般说的‘主线程’实际上是main函数的线程，而所谓主线程结束子线程也会结束是因为在主线程结束时调用了系统的退出函数。而守护线程是指‘不重要线程’。主线程会等所有‘重要’线程结束后才结束。通常当客户端访问服务器时会为这次访问开启一个守护线程。将setDaemon属性设为True即可将该线程设为守护线程。\n```python\nfrom threading import Thread\n\nn = 100\n\ndef count(x,y):\n    return n=x+y\n\nif __name__ == \'__main__\':\n\n    t = Thread(target=count,args=(1,2))\n    t.setDaemon = True\n    # ...\n```\n','<h1>什么是进程/线程</h1>\n<p>众所周知，CPU是计算机的核心，它承担了所有的计算任务。而操作系统是计算机的管理者，是一个大管家，它负责任务的调度，资源的分配和管理，统领整个计算机硬件。应用应用程序是具有某种功能的程序，程序运行与操作系统之上。</p>\n<h2>进程</h2>\n<p>进程时一个具有一定功能的程序在一个数据集上的一次动态执行过程。进程由程序，数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时需要的数据和工作区；程序控制块（PCB）包含程序的描述信息和控制信息，是进程存在的唯一标志。</p>\n<h2>线程</h2>\n<p>在很早的时候计算机并没有线程这个概念，但是随着时代的发展，只用进程来处理程序出现很多的不足。如当一个进程堵塞时，整个程序会停止在堵塞处，并且如果频繁的切换进程，会浪费系统资源。所以线程出现了。<br>\n线程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。一个进程可以拥有多个线程，而且属于同一个进程的多个线程间会共享该进行的资源。</p>\n<h2>进程与线程的区别</h2>\n<ol>\n<li>一个进程由一个或者多个线程组成，线程是一个进程中代码的不同执行路线。</li>\n<li>切换进程需要的资源比切换线程的要多的多。</li>\n<li>进程之间相互独立，而同一个进程下的线程共享程序的内存空间（如代码段，数据集，堆栈等）。某进程内的线程在其他进程不可见。换言之，线程共享同一片内存空间，而进程各有独立的内存空间。\n以下是作者在知乎上看到的关于进程与线程的讨论，其中一个作者感觉很有道理，摘抄如下：<blockquote><p>作者：zhonyong\n链接：<a href=\"https://www.zhihu.com/question/25532384/answer/81152571\" rel=\"nofollow\">https://www.zhihu.com/question/25532384/answer/81152571</a>\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n</li>\n</ol>\n<blockquote><p>首先来一句概括的总论：进程和线程都是一个时间段的描述，是CPU工作时间段的描述。下面细说背景：CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。一个必须知道的事实：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。<br>\n========= 重要的东西出现了========<br>\n进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文线程是什么呢？进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。到此全文结束，再一个总结：进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</p>\n</blockquote>\n<h1>开进程需要时间</h1>\n<p>学习《python爬虫开发与项目实践》时，执行下面一段代码：</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">multiprocessing</span> <span class=\"kn\">import</span> <span class=\"n\">Process</span>\n<span class=\"kn\">import</span> <span class=\"nn\">os</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">run_process</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">):</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Child process </span><span class=\"si\">%s</span><span class=\"s2\"> (</span><span class=\"si\">%s</span><span class=\"s2\">) is running\"</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">getpid</span><span class=\"p\">()))</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s2\">\"parant process </span><span class=\"si\">%s</span><span class=\"s2\"> \"</span> <span class=\"o\">%</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">getpid</span><span class=\"p\">())</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">):</span>\n        <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">Process</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"n\">run_process</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">),))</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s2\">\"process will start\"</span><span class=\"p\">)</span>\n        <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n    <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">()</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s2\">\"process end\"</span><span class=\"p\">)</span>\n</pre></div>\n<p>显示的结果是</p>\n\n<pre><code>parant process 6332 \nprocess will start\nprocess will start\nprocess will start\nprocess will start\nprocess will start\nChild process 2 (9896) is running\nChild process 0 (11208) is running\nChild process 3 (5464) is running\nChild process 1 (10208) is running\nChild process 4 (12596) is running\nprocess end</code></pre>\n<p>可以看到，程序在执行完</p>\n\n<pre><code>print (\"parant process %s \" % os.getpid())</code></pre>\n<p>没有接着马上执行run_process()，而是先打印process will start，最后把子进程一起执行。这是因为子进程的创建是需要时间的，在这个空闲时间里父进程继续执行代码，而子进程在创建完成后显示。</p>\n<h1>Pool进程池</h1>\n<p>需要创建多个进程时，可以使用multiprocessing中的Pool类开进程池。Pool()默认开启数量等于当前cpu核心数的子进程（当然可以手动改变）</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">multiprocessing</span> <span class=\"kn\">import</span> <span class=\"n\">Pool</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">hello</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">):</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s2\">\"hello ,this is the </span><span class=\"si\">%d</span><span class=\"s2\"> process\"</span> <span class=\"o\">%</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">Pool</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">):</span>\n        <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">apply_async</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"n\">hell0</span><span class=\"p\">,</span><span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,))</span>\n    <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">close</span>    \n    <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">join</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre></div>\n<p>apply_async表示在开进程时不阻塞主进程，是异步IO的一种方式之一。targe参数传入要在子线程中执行的<strong>函数对象</strong>，args以元组的方式传入函数的参数。<br>\njoin会等待线程池中的每一个线程执行完毕，在调用join之前必须要先调用close，close表示不能再向线程池中添加新的process了。</p>\n<h1>进程间的通信</h1>\n<p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。假如创建了多个进程，那么进程间的通信是必不可少的。Python提供了多种进程通信的方式，其中以Queue和Pipe用得最多。下面分别介绍这两种模式。</p>\n<h2>Queue</h2>\n<p>Queue是一种<strong>多进程</strong>安全的队列。实现多进程间的通信有两种方法：</p>\n<ul>\n<li>get() 用于向队列中加入数据。有两个属性：blocked和timeout。blocked为true时（默认为True）且timeout为正值时，如果当队列已满会阻塞timeout时间，在这个时间内如果队列有空位会加入，如果超过时间仍然没有空位会抛出Queue.Full异常。</li>\n<li>put() 用于从队列中获取一个数据并将其从队列中删除。有两个属性：blocked和timeout。blocked为true（默认为True）且timeout为正值时，如果当前队列为空会阻塞timeout时间，在这个时间内如果队列有新数据会获取，如果超过时间仍然没有新数据会抛出Queue.Empty异常。\n```python\nfrom multiprocessing import Process,Queue\nimport os</li>\n</ul>\n<p>def put_data(q,nums):\n    print(\'现在的进程编号为：%s，这是一个put进程\' % os.getpid())\n    for num in nums:\n        q.put(num)\n        print(\'%d已经放入队列中啦！\' % num)</p>\n<p>def get_data(q):\n    print(\'现在的进程编号为：%s，这是一个get进程\' % os.getpid())\n    while True:\n        print(\'已经从队列中获取%s并从中删除\' % q.get())</p>\n<p>if <strong>name</strong> == \'<strong>main</strong>\':\n    q = Queue()\n    p1 = Process(target=put_data,args=(q,[\'1\',\'2\',\'3\'],))\n    p2 = Process(target=put_data,args=(q,[\'4\',\'5\',\'6\'],))\n    p3 = Process(target=get_data,args=(q,))\n    p1.start()\n    p2.start()\n    p3.start()\n    p1.join()\n    p2.join()</p>\n\n<pre><code># p3是个死循环，需要手动结束这个进程\np3.terminate()\n</code></pre>\n\n<pre><code>我们来看一下运行结果：</code></pre>\n<p>现在的进程编号为：10336，这是一个put进程\n1已经放入队列中啦！\n2已经放入队列中啦！\n3已经放入队列中啦！\n现在的进程编号为：9116，这是一个get进程\n已经从队列中获取1,并从中删除\n已经从队列中获取2并从中删除\n已经从队列中获取3并从中删除\n现在的进程编号为：2732，这是一个put进程\n4已经放入队列中啦！\n5已经放入队列中啦！\n已经从队列中获取4,并从中删除\n6已经放入队列中啦！\n已经从队列中获取5并从中删除\n已经从队列中获取6并从中删除</p>\n\n<pre><code>## Pipe\nPipe与Queue不同之处在于Pipe是用于**两个进程**之间的通信。就像进程位于一根水管的两端。让我们看看Pipe官方文档的描述：  \n&gt; Returns a pair (conn1, conn2) of Connection objects representing the ends of a pipe.\n\nPiep返回conn1和conn2代表水管的两端。Pipe还有一个参数duplex（adj. 二倍的，双重的 n. 双工；占两层楼的公寓套房），默认为True。当duplex为True时，开启双工模式，此时水管的两边都可以进行收发。当duplex为False，那么**conn1只负责接受信息，conn2只负责发送信息。**  \nconn通过send()和recv()来发送和接受信息。值得注意的是，如果管道中没有信息可接受，recv()会一直阻塞直到管道关闭（任意一端进程接结束则管道关闭）。\n```python\nfrom multiprocessing import Process,Pipe\nimport os\n\ndef put_data(p,nums):\n    print(\'现在的进程编号为：%s，这个一个send进程\' % os.getpid())\n    for num in nums:\n        p.send(num)\n        print(\'%s已经放入管道中啦！\' % num)\n\ndef get_data(p):\n    print(\'现在的进程编号为：%s，这个一个recv进程\' % os.getpid())\n    while True:\n        print(\'已经从管道中获取%s并从中删除\' % p.recv())\n\nif __name__ == \'__main__\':\n    p = Pipe(duplex=False)\n    # 此时Pipe[1]即是Pipe返回的conn2\n    p1 = Process(target=put_data,args=(p[1],[\'1\',\'2\',\'3\'],))\n    # 此时Pipe[0]即是Pipe返回的conn1\n    p3 = Process(target=get_data,args=(p[0],))\n    p1.start()\n    p3.start()\n    p1.join()\n    p3.terminate()</code></pre>\n<p>让我们看一下输出结果</p>\n\n<pre><code>现在的进程编号为：9868，这个一个recv进程\n现在的进程编号为：9072，这个一个send进程\n1已经放入管道中啦！\n已经从管道中获取1,并从中删除\n2已经放入管道中啦！\n已经从管道中获取2并从中删除\n3已经放入管道中啦！\n已经从管道中获取3并从中删除</code></pre>\n<h1>控制线程</h1>\n<p>我们是没有办法完全人为控制线程的，因为线程由系统控制。但是可以用一些方式来影响线程的调用，比如互斥锁，sleep（阻塞），死锁等。</p>\n<h2>线程的几种状态</h2>\n<p>新建-----就绪------------------运行-----死亡<br>\n                        等待（阻塞）<br>\n线程的生命周期由run方法决定，当run方法结束时线程死亡。可以通过继承Thread，重写run方法改变Thread的功能，最后还是通过start()方法开线程。</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">threading</span> <span class=\"kn\">import</span> <span class=\"n\">Thread</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyThread</span><span class=\"p\">(</span><span class=\"n\">Thread</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">run</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">\'i am sorry\'</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">\'__main__\'</span><span class=\"p\">:</span>\n    <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">MyThread</span><span class=\"p\">()</span>\n    <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n</pre></div>\n<p>通过args参数以一个元组的方式给线程中的函数传参。</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">threading</span> <span class=\"kn\">import</span> <span class=\"n\">Thread</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">sorry</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">):</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">\'i am sorry\'</span><span class=\"p\">,</span><span class=\"n\">name</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">\'__main__\'</span><span class=\"p\">:</span>  \n    <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">Thread</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"n\">sorry</span><span class=\"p\">,</span><span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">\'mike\'</span><span class=\"p\">))</span>\n    <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n</pre></div>\n<h2>线程锁</h2>\n<p>多线程中任务中，可能会发生多个线程同时对一个公共资源（如全局变量）进行操作的情况，这是就会发生混乱。为了避免这种情况，需要引入线程锁的概念。只有一个线程能处于上锁状态，当一个线程上锁之后，如果有另外一个线程试图获得锁，该线程就会挂起直到拥有锁的线程将锁释放。这样就保证了同时只有一个线程对公共资源进行访问或修改。</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">threading</span> <span class=\"kn\">import</span> <span class=\"n\">Thread</span><span class=\"p\">,</span><span class=\"n\">Lock</span>\n\n<span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"k\">def</span> <span class=\"nf\">puls</span><span class=\"p\">():</span>\n    <span class=\"c1\"># 获得一个锁</span>\n    <span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"n\">Lock</span><span class=\"p\">()</span>\n    <span class=\"k\">global</span> <span class=\"n\">num</span>\n    <span class=\"c1\"># acquire()方法上锁</span>\n    <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"n\">acquire</span><span class=\"p\">()</span>\n    <span class=\"n\">num</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span>\n    <span class=\"c1\"># release()方法解锁</span>\n    <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"n\">release</span><span class=\"p\">()</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">\'__main__\'</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">):</span>\n        <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">Thread</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"n\">plus</span><span class=\"p\">)</span>\n        <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n    <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">()</span>\n</pre></div>\n<p>join()方法会阻塞主线程直到子线程全部结束（也就是同步）。<br>\n<br>\n锁的用处:</p>\n<ol>\n<li>确保某段关键代码只能由一个线程从头到尾执行，保证了数据的唯一性。  </li>\n</ol>\n<p>锁的坏处:</p>\n<ol>\n<li>阻止了多线程并发执行，效率大大降低。</li>\n<li>由于存在多个锁，不同的线程持有不同的锁并试图获取对方的锁时，可能造成死锁。  </li>\n</ol>\n<h1>守护线程</h1>\n<p>线程其实并没有主次的概念，我们一般说的‘主线程’实际上是main函数的线程，而所谓主线程结束子线程也会结束是因为在主线程结束时调用了系统的退出函数。而守护线程是指‘不重要线程’。主线程会等所有‘重要’线程结束后才结束。通常当客户端访问服务器时会为这次访问开启一个守护线程。将setDaemon属性设为True即可将该线程设为守护线程。</p>\n<div class=\"highlight\"><pre><span></span><span class=\"kn\">from</span> <span class=\"nn\">threading</span> <span class=\"kn\">import</span> <span class=\"n\">Thread</span>\n\n<span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">count</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"n\">x</span><span class=\"o\">+</span><span class=\"n\">y</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">\'__main__\'</span><span class=\"p\">:</span>\n\n    <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">Thread</span><span class=\"p\">(</span><span class=\"n\">target</span><span class=\"o\">=</span><span class=\"n\">count</span><span class=\"p\">,</span><span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n    <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">setDaemon</span> <span class=\"o\">=</span> <span class=\"bp\">True</span>\n    <span class=\"c1\"># ...</span>\n</pre></div>\n','2018-04-08 02:24:01');
/*!40000 ALTER TABLE `python` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `talk`
--

DROP TABLE IF EXISTS `talk`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `talk` (
  `id` tinyint(4) NOT NULL AUTO_INCREMENT,
  `title` varchar(64) NOT NULL,
  `body` longtext,
  `body_html` longtext,
  `timestamp` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `talk`
--

LOCK TABLES `talk` WRITE;
/*!40000 ALTER TABLE `talk` DISABLE KEYS */;
INSERT INTO `talk` VALUES (1,'一点感想','今天开了个学情分析会，说实话我觉得很无聊。本来大学里的学习就不应该再像中学似的一切绕着成绩转，当然不是说成绩就不重要了，只是我想到了现在更重要的是磨炼自己的技能，增长见识。其实以前也好，现在也好，成绩讲究的是一个够用，这个标准自然因人而异：考二本的400+够用，要考清北的670+够用，想要混过4年的不挂科就够用，想要保研的3.5+才够用......对我而言，上学期的成绩是否够用还是个未知数，一切还要再等3个月才能知晓。不过不管是不是够用，大概都是有一个遗憾的：最重视的数学和英语学的并不好，这点倒是令我挺难受。其他的课程学的好也罢，差也罢，我并不是很在乎，唯独这两门我是没办法做到不在意的。  \n还有就是写代码这件事了。接触这行也是机缘巧合。后来学得多了些，慢慢地也开始体会到乐趣所在，现在是CS的黄金年代，大量的人一拥而入，这是很正常的。但是不得不说如今的CS已经积累到了量变的程度，人工智能,区块链，云计算......这些方向都是多学科交叉的，统计学，数学，计算机科学，甚至物理学...以前那种能写些网站和app，会调个库，但是对底层一无所知还能被称为程序员的的时代已经快要过去了，未来必定会要求程序员对数据结构，算法，各种协议甚至硬件有更深的理解。  \n路还很长，要努力啊','<p>今天开了个学情分析会，说实话我觉得很无聊。本来大学里的学习就不应该再像中学似的一切绕着成绩转，当然不是说成绩就不重要了，只是我想到了现在更重要的是磨炼自己的技能，增长见识。其实以前也好，现在也好，成绩讲究的是一个够用，这个标准自然因人而异：考二本的400+够用，要考清北的670+够用，想要混过4年的不挂科就够用，想要保研的3.5+才够用......对我而言，上学期的成绩是否够用还是个未知数，一切还要再等3个月才能知晓。不过不管是不是够用，大概都是有一个遗憾的：最重视的数学和英语学的并不好，这点倒是令我挺难受。其他的课程学的好也罢，差也罢，我并不是很在乎，唯独这两门我是没办法做到不在意的。<br>\n还有就是写代码这件事了。接触这行也是机缘巧合。后来学得多了些，慢慢地也开始体会到乐趣所在，现在是CS的黄金年代，大量的人一拥而入，这是很正常的。但是不得不说如今的CS已经积累到了量变的程度，人工智能,区块链，云计算......这些方向都是多学科交叉的，统计学，数学，计算机科学，甚至物理学...以前那种能写些网站和app，会调个库，但是对底层一无所知还能被称为程序员的的时代已经快要过去了，未来必定会要求程序员对数据结构，算法，各种协议甚至硬件有更深的理解。<br>\n路还很长，要努力啊</p>','2018-04-05 06:48:48');
/*!40000 ALTER TABLE `talk` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-04-14 20:29:34
